<template>
    <div class="lessonGrid">
        <div class="header">
            <h3 text-h3>{{this.currentStage}}</h3><br><br>
            <span text-body1>{{this.lessonText && this.lessonText[this.currentStage][this.textIndex].text}}</span><br>
        </div>

        <div class="controller">
            <shadowpad :controllerDetails="configObject" />
            <!-- <controller :controllerDetails="configObject" /> -->
            <span text-body1>Controller</span>
        </div>
        <div class="hint">
            <span class="middleText" text-body1>{{this.currentQuestion && this.currentQuestion.hint}}</span><br>
            <span class="bottomText" text-body1>Hint</span>
        </div>
        <div class="function">
            <span class="outcome" text-body1 :style="{color: outcomeColour}">{{this.outcome}}</span>
            <h3 class="middleText" text-h3>{{this.currentQuestion && this.currentQuestion.operationName}}</h3><br>
            <span class="bottomText" text-body1>Function</span>
        </div>
        <div class="progress">
            <span v-for="(section, index) in Object.keys(stagesToIndex)" :key="index">
            <span text-body1>{{section}}</span>
            <q-linear-progress size="25px" style="width: 20vw" :value="questionsAnswered[section]/questionTotalCount[section]" :key="questionsAnswered[section]" />
            </span>
        </div>
    </div>
</template>

<script>

import Controller from './Controller.vue'
import Shadowpad from './Shadowpad.vue'

import * as questionGeneratorClass from './QuestionGenerator.js'

// Text will be presented at all times
// text index will need to be incremented in the introduction stage,
// this will be handled by a function which needs to be called on mount
// and after a correct response (during introduction only)

// Questions will be generated by nextQuestion
// nextQuestion needs to be called by nextText at the right indicies
// and also when incrementing the stage from Introduction

// nextQuestion will be called by the timeout in setOutcome
// if not in Introduction stage

    export default {
        components: { Controller, Shadowpad },
        props: ["configObject"],
        data() {
            return {
                currentQuestion: null,
                textIndex: 0,
                questionsAnswered: {
                    Introduction: 0,
                    Practice: 0,
                    Review: 0,
                    Test: 0,
                },
                questionTotalCount: {
                    Introduction: 2,
                    Practice: 1,
                    Review: 1,
                    Test: 1,
                },
                stagesToIndex: {
                    Introduction: 0,
                    Practice: 1,
                    Review: 2,
                    Test: 3
                },
                questionGenerator: null,
                openToEvents: false,
                currentStage: "Introduction",
                lessonText: null,
                // Briefly stores either Correct! or Incorrect! after the user has activated a function
                outcome: null,
                // records the start time in order to calculate the total time
                startTime: null,
                // records number of error of each question type
                errors: {},
                // records the number of times the test stage was failed
                testFailedNum: 0,
                // records the response time for each question answered correctly
                correctResponseTimes: [],
                // records the response time for each question answered incorrectly
                incorrectResponseTimes: [],

                correctBuildTimes: [],

                incorrectBuildTimes: [],

                correctDwellTimes: [],

                incorrectDwellTimes: [],
                // records the start time of the current question for the purpose of calculating response time
                currentResponseStartTime: null,
            }
        },
        computed: {
            outcomeColour(){
                if (this.outcome == "Correct!"){
                    return "green";
                } else {
                    return "red";
                }
            }
        },
        methods: {
            // Checks if two arrays are equal using one of many possible ways
            arrayEquals(first, second){
                if (first.length != second.length){
                    return false;
                }
                for (let i = 0; i < first.length; i++){
                    if (first[i] != second[i]){
                    return false;
                    }
                }
                return true;
            },
            // Shuffles an array and returns an array with the original elements in a random order
            // Taken from the internet somewhere (I don't remember where)
            shuffle(array) {
                var m = array.length, t, i;
                // While there remain elements to shuffle
                while (m) {
                    // Pick a remaining elementâ€¦
                    i = Math.floor(Math.random() * m--);
                    // And swap it with the current element.
                    t = array[m];
                    array[m] = array[i];
                    array[i] = t;
                }
                return array;
            },
            // gets the average of an array
            average(array) {
                return array.reduce((ac, v) => {return ac + v}, 0) / array.length;
            },
            // needs to be called on mount and when a intro question is answered
            // otherwise either takes care of itself or is not required
            nextText(){
                // Only scroll through text in the intro
                // Don't automatically queue the next text for questions which are waiting for an answer
                // when a correct answer has been provided, call this function with answered = true
                if (this.currentStage == "Introduction"){
                    if (this.textIndex < this.lessonText[this.currentStage].length - 1){
                        this.textIndex += 1;
                        // if the current text index isn't 2 or 4
                        // these sections require responses
                        if (![2, 4].includes(this.textIndex)){
                            window.setTimeout(this.nextText.bind(this), 3000);
                        } else {
                            // if the current text index is 2 or 4,
                            // provide the question the user needs to answer
                            this.nextQuestion();
                        }
                    } else {
                        // move from introduction to practice
                        this.nextStage();
                    }
                }
            },
            nextQuestion(last){
                this.currentResponseStartTime = new Date();
                var question;
                if (last){
                    question = this.questionGenerator.getQuestionWithHint(last);
                } else {
                    question = this.questionGenerator.questionFromStage(this.currentStage);
                }
                if (question == -1){ // progress to next stage
                    this.nextStage();
                } else {
                    this.currentQuestion = question;
                    this.openToEvents = true;
                }
            },
            // brings the user back to the start of the review stage
            // to be called when the user fails a question on either
            // the review or test stage
            resetToReview(){
                // reset the questions answered
                this.questionsAnswered.Review = 0
                this.questionsAnswered.Test = 0;
                // change the text associated with the start of review
                this.lessonText.Review[0].text = "You answered a question incorrectly! Let's review the functions again."
                // reset the question index
                this.questionGenerator.setQuestionIndex(0);
                // set the stage to review
                this.currentStage = "Review";

            },
            handleOperation(event){
                // check if waiting for a response
                if (this.openToEvents){
                    this.openToEvents = false;
                    var now = new Date();
                    var responseTime = now - this.currentResponseStartTime;
                    this.currentResponseStartTime = null;
                    // check whether answer is correct or incorrect
                    if (event.detail.activeOperation == this.currentQuestion.operationName){ // answer is correct
                        // record response time in correct array
                        this.correctResponseTimes.push(responseTime);
                        this.correctBuildTimes.push(event.detail.buildTime);
                        this.correctDwellTimes.push(event.detail.dwellTime);
                        this.questionsAnswered[this.currentStage] += 1;
                        if (this.currentStage == "Introduction"){
                            this.nextText();
                        }
                        this.setOutcome("Correct!");
                    } else { // answer is incorrect
                        // record response time in incorrect array
                        this.incorrectResponseTimes.push(responseTime);
                        this.incorrectBuildTimes.push(event.detail.buildTime);
                        this.incorrectDwellTimes.push(event.detail.dwellTime);
                        console.log("this.average(this.incorrectDwellTimes): ", this.average(this.incorrectDwellTimes));
                        // if they are in the practice stage, add more questions to this question type
                        if (this.currentStage == "Practice"){
                            // if you would like to add more questions to a stage when a user
                            // answers incorrectly, do it here
                            var questionsToAdd = 1;
                            this.questionGenerator.addQuestionsToStage("Practice", this.currentQuestion, questionsToAdd);
                            this.questionTotalCount[this.currentStage] += questionsToAdd;
                        } else if (["Review", "Test"].includes(this.currentStage)) {
                            if (this.currentStage == "Test"){
                                this.testFailedNum += 1;
                                console.log("test failed: ", this.testFailedNum);
                            }
                            // if they are in review or test, reset to review
                            this.resetToReview();
                        }
                        
                        if (this.errors.hasOwnProperty(this.currentQuestion.operationName)) {
                            this.errors[this.currentQuestion.operationName] += 1;
                        } else {
                            this.errors[this.currentQuestion.operationName] = 1;
                        }
                        this.setOutcome("Incorrect!");
                    }
                }
            },
            setOutcome(val){
                this.outcome = val;
                var old = this.currentQuestion;
                this.timeout = window.setTimeout(() => {
                    this.outcome = null;
                    this.currentQuestion = null;
                    if (!(this.currentStage == "Introduction" && val == "Correct!")){
                        if (val == "Correct!"){
                            this.nextQuestion();
                        } else {
                            this.nextQuestion(old);
                        }
                    }
                }, 1500);
            },
            nextStage(){
                if (this.currentStage == "Test"){
                    this.finish()
                } else {
                    // get an array of strings
                    var stages = Object.keys(this.stagesToIndex);
                    // figure out where in that array the name of the next stage is
                    var next = this.stagesToIndex[this.currentStage] + 1;
                    // reset the question index on the question generator
                    this.questionGenerator.setQuestionIndex(0);
                    if (this.currentStage == "Introduction"){
                        // textIndex should be at 0 on every stage except for introduction
                        this.textIndex = 0;
                    }
                    // set the next stage
                    this.currentStage = stages[next];
                    this.nextQuestion();
                }
            },
            finish(){
                // find the overall time taken
                var timeTaken = new Date() - this.startTime;
                // find the most common and least common error
                var keys = Object.keys(this.errors);
                if (keys.length > 0){
                    var min = this.errors[keys[0]];
                    var max = this.errors[keys[0]];
                    var mostCommonError = keys[0];
                    var leastCommonError = keys[0];
                    for (let i = 1; i < keys.length; i++) {
                        var value = this.errors[keys[i]];
                        if (value < min) {
                            min = value;
                            leastCommonError = keys[i];
                        }
                        if (value > max) {
                            max = value;
                            mostCommonError = keys[i];
                        }
                    }
                }
                // calculate average time for correct responses
                var averageResponseTimeCorrect = this.average(this.correctResponseTimes);
                var averageResponseTimeIncorrect = this.average(this.incorrectResponseTimes);
                var averageBuildTimeCorrect = this.average(this.correctBuildTimes);
                var averageBuildTimeIncorrect = this.average(this.incorrectBuildTimes);
                var averageDwellTimeCorrect = this.average(this.correctDwellTimes);
                var averageDwellTimeIncorrect = this.average(this.incorrectDwellTimes);
                // report the results to the main component
                this.$emit('report', {
                    timeTaken,
                    leastCommonError,
                    mostCommonError,
                    testFailedNum: this.testFailedNum,
                    averageResponseTimeCorrect,
                    averageResponseTimeIncorrect,
                    averageBuildTimeCorrect,
                    averageBuildTimeIncorrect,
                    averageDwellTimeCorrect,
                    averageDwellTimeIncorrect
                })
                // emit navigation and stats to main page
                this.$emit('navigate-to', "End");
            },






            // This function is to be called either when a question is answered,
            // or when the timeout on a prompt that doesn't expect an answer has expired
            // It will increment the index pointing to the current question/prompt
            // It will increment the stage and reset the index if the current stage has been completed
            // It will also emit a navigation event if the last stage has been completed
            // nextQuestion() {
            //     this.outcome = null;
            //     // increment the question index
            //     this.currentQuestion += 1;
            //     // if current stage has been completed
            //     if (this.currentQuestion >= this.lessonPlan[this.stages[this.currentStage]].length){
            //         // if lesson plan has been completed
            //         if (this.currentStage >= (this.stages.length - 1)){
            //             // find the overall time taken
            //             var timeTaken = new Date() - this.startTime;
            //             // find the most common and least common error
            //             var keys = Object.keys(this.errors);
            //             var min = this.errors[keys[0]];
            //             var max = this.errors[keys[0]];
            //             var mostCommonError = keys[0];
            //             var leastCommonError = keys[0];
            //             for (let i = 1; i < keys.length; i++) {
            //                 var value = this.errors[keys[i]];
            //                 if (value < min) {
            //                     min = value;
            //                     leastCommonError = keys[i];
            //                 }
            //                 if (value > max) {
            //                     max = value;
            //                     mostCommonError = keys[i];
            //                 }
            //             }
            //             // calculate average time for correct responses
            //             var averageResponseTimeCorrect = this.average(this.correctResponseTimes);
            //             var averageResponseTimeIncorrect = this.average(this.incorrectResponseTimes);
            //             var averageBuildTimeCorrect = this.average(this.correctBuildTimes);
            //             var averageBuildTimeIncorrect = this.average(this.incorrectBuildTimes);
            //             var averageDwellTimeCorrect = this.average(this.correctDwellTimes);
            //             var averageDwellTimeIncorrect = this.average(this.incorrectDwellTimes);
            //             // report the results to the main component
            //             this.$emit('report', {
            //                 timeTaken,
            //                 leastCommonError,
            //                 mostCommonError,
            //                 testFailedNum: this.testFailedNum,
            //                 averageResponseTimeCorrect,
            //                 averageResponseTimeIncorrect,
            //                 averageBuildTimeCorrect,
            //                 averageBuildTimeIncorrect,
            //                 averageDwellTimeCorrect,
            //                 averageDwellTimeIncorrect
            //             })
            //             // emit navigation and stats to main page
            //             this.$emit('navigate-to', "End");
            //             return 0;
            //         } else {
            //             this.currentStage += 1;
            //             this.currentQuestion = 0;
            //         }
            //     }
            //     // if the new question does not have a operationName, queue this function again
            //     if (!this.lessonPlan[this.stages[this.currentStage]][this.currentQuestion].hasOwnProperty("operationName")){
            //         this.queueNextQuestion();
            //     } else {
            //         this.currentResponseStartTime = new Date();
            //     }
            // },
            // // Updates the value stored in the progress array to reflect how many questions are left in the stage
            // // Called after incrementing the index and/or stage and after adding any additional questions that need to be added
            // // Since it is called after incrementing the index or stage, it needs to look back one stage if the index is 0 and the stage isn't 0
            // updateProgress(){
            //     if (this.currentStage != 0 && this.currentQuestion == 0) {
            //         // if a new stage has just been started, we need to update the progress on the last stage to 100%
            //         this.progress[this.currentStage - 1] = 1;
            //         // we also need to update the progress on the current stage to 0 to account for the case where
            //         // a user is brought back to review from test, in which progress for review needs to be cleared
            //         this.progress[this.currentStage] = 0;
            //     } else {
            //         // otherwise, figure out how many actual questions (not just prompts) have been answered
            //         // and how many are yet to be answered
            //         var currentLessonPlan = this.lessonPlan[this.stages[this.currentStage]];
            //         var past = currentLessonPlan.slice(0,this.currentQuestion);
            //         var future = currentLessonPlan.slice(this.currentQuestion, currentLessonPlan.length);
            //         // make sure to only look at actual questions
            //         var numPast = past.filter(elem => elem.hasOwnProperty("operationName")).length;
            //         var numFuture = future.filter(elem => elem.hasOwnProperty("operationName")).length;
            //         // update progress
            //         this.progress[this.currentStage] = numPast/(numPast + numFuture);
            //     }

            // },
            // // adds a question to the current stage at the specified index
            // // question is an object with a targetOperation string and a prompt string, and index is a number
            // addQuestion(question, index){
            //     this.lessonPlan[this.stages[this.currentStage]].splice(index, 0, question);
            // },
            // generateLessonPlan(){
            //     // generate intro
            //     // mostly prompts without questions, some questions to allow user to familiarise themselves with the
            //     // relationship between button presses and functions
            //     // An incorrect answer will not add additional questions or change the current question index
            //     // Since they will always have a prompt with a question, the user will stay on a question until they get it correct
            //     // var randomRule = Math.floor(Math.random() * this.configObject.rules.length);
            //     var randomRule = 0;
            //     this.lessonPlan.Introduction = [
            //         {
            //             prompt: "You will be shown which button to press",
            //         },
            //         {
            //             prompt: "For example, to activate " + this.configObject.rules[randomRule].operationName + ", " + this.configObject.rules[randomRule].prompt.toLowerCase(),
            //         },
            //         {
            //             prompt: "Try it now: " + this.configObject.rules[randomRule].prompt,
            //             operationName: this.configObject.rules[randomRule].operationName
            //         },
            //         {
            //             prompt: "? means remember what to press",
            //         },
            //         {
            //             prompt: "Try it now: ?",
            //             operationName: this.configObject.rules[randomRule].operationName
            //         },
            //         {
            //             prompt: "You got it!",
            //         },
            //         {
            //             prompt: "There are " + this.configObject.rules.length + " functions to learn",
            //         },
            //         {
            //             prompt: "Press and release the buttons for each function"
            //         },
            //         {
            //             prompt: "Let's practice the functions"
            //         }
            //     ];
            //     // generate practice
            //     // front loaded by question pairs that contain a prompt for how to activate the function,
            //     // and then a question on the same function without a prompt
            //     // if the user gets a prompted question wrong, they remain on the same question and an extra unprompted question is added to the plan
            //     // if the user gets an unprompted question wrong, a prompted question is inserted at the current index, and an an extra unprompted question is added to the plan
            //     var randomPractice = [];
            //     for (let i = 0; i < this.configObject.rules.length; i++){
            //         this.lessonPlan.Practice.push(
            //             {prompt: this.configObject.rules[i].prompt,
            //             operationName: this.configObject.rules[i].operationName}
            //         )
            //         this.lessonPlan.Practice.push(
            //             {prompt: "?",
            //             operationName: this.configObject.rules[i].operationName}
            //         )
            //         for (let j = 0; j < this.configObject.rules[i].practiceCount; j++) {
            //             randomPractice.push(
            //                 {prompt: "?",
            //                 operationName: this.configObject.rules[i].operationName}
            //             )
            //         }
            //     }
            //     randomPractice = this.shuffle(randomPractice);
            //     this.lessonPlan.Practice = this.lessonPlan.Practice.concat(randomPractice);
            //     // generate review
            //     // review is short and is just the front part of practice (pairs of question with prompt and same question without prompt)
            //     this.lessonPlan.Review.push({
            //         prompt: "Now we will review all of the functions"
            //     });
            //     for (let i = 0; i < this.configObject.rules.length; i++){
            //         this.lessonPlan.Review.push({
            //             prompt: this.configObject.rules[i].prompt,
            //             operationName: this.configObject.rules[i].operationName
            //         });
            //         this.lessonPlan.Review.push({
            //             prompt: "?",
            //             operationName: this.configObject.rules[i].operationName
            //         });
            //     }
            //     // generate test
            //     // no prompts after the first one, random order
            //     this.lessonPlan.Test.push({
            //         prompt: "Now we will test you. Answering incorrectly will bring you back to the review stage."
            //     });
            //     var testStage = [];
            //     for (let i = 0; i < this.configObject.rules.length; i++) {
            //         for (let j = 0; j < this.configObject.rules[i].testCount; j++) {
            //             testStage.push({
            //                 prompt: "?",
            //                 operationName: this.configObject.rules[i].operationName
            //             })
            //         }
            //     }
            //     // shuffle it
            //     testStage = this.shuffle(testStage);
            //     this.lessonPlan.Test = this.lessonPlan.Test.concat(testStage);
            // },
            // setOutcome(val){
            //     this.outcome = val;
            //     // if the user is progressing so rapidly that there is still a resetting timeout
            //     // by the time they have answered the next question, clear the timeout to prevent
            //     // the next outcome being removed too quickly
            //     if (this.timeout != null){
            //         window.clearTimeout(this.timeout);
            //     }
            //     this.timeout = window.setTimeout(() => {
            //         this.outcome = null
            //         this.nextQuestion();
            //         this.updateProgress();
            //     }, 1500);
            // },
            // // single point for queueing next question
            // // for changing the timeout in a single place
            // queueNextQuestion(){
            //     var question = this.lessonPlan[this.stages[this.currentStage]][this.currentQuestion];
            //     // do a check first to make sure that something hasn't called this function while
            //     // waiting for the user to answer
            //     if (question && !question.hasOwnProperty("operationName")){
            //         window.setTimeout(this.nextQuestion.bind(this), 3000);
            //     }
            // },
            // operated(event){
            //     // Make sure there is an active question waiting for a response before trying to
            //     // figure out whether the response is correct
            //     var question = this.lessonPlan[this.stages[this.currentStage]][this.currentQuestion];
            //     if (question && question.hasOwnProperty("operationName")){
            //         console.log("comparing ", event.detail.activeOperation, " with ", question.operationName)
            //         if (event.detail.activeOperation == question.operationName){
            //             var now = new Date();
            //             // record response time in correct array
            //             this.correctResponseTimes.push(now - this.currentResponseStartTime);
            //             this.correctBuildTimes.push(event.detail.buildTime);
            //             this.correctDwellTimes.push(event.detail.dwellTime);
            //             // answer is correct
            //             this.setOutcome("Correct!");
            //         } else {
            //             var now = new Date();
            //             // record response time in incorrect array
            //             this.incorrectResponseTimes.push(now - this.currentResponseStartTime);
            //             this.incorrectBuildTimes.push(event.detail.buildTime);
            //             this.incorrectDwellTimes.push(event.detail.dwellTime);
            //             // answer is incorrect
            //             this.setOutcome("Incorrect!");
            //             if (this.errors.hasOwnProperty(question.operationName)) {
            //                 this.errors[question.operationName] += 1;
            //             } else {
            //                 this.errors[question.operationName] = 1;
            //             }
            //             // if in the intro stage,
            //             // An incorrect answer will not add additional questions or change the current question index
            //             // Since they will always have a prompt with a question, the user will stay on a question until they get it correct
            //             if (this.currentStage == 0) {
            //                 ;
            //             }
            //             // if in the practice stage,
            //             // if the user gets a prompted question wrong, they remain on the same question and an extra unprompted question is added to the plan
            //             // if the user gets an unprompted question wrong, a prompted question is inserted at the current index, and an an extra unprompted question is added to the plan
            //             else if (this.currentStage == 1) {
            //                 if (question.prompt == "?"){
            //                     // if there is no prompt, we need to figure out what an actually useful prompt would be
            //                     // since practice is front loaded with questions that have prompts, we can grab the prompt
            //                     // of the first question with a matching targetOperation
            //                     var usefulPrompt = this.configObject.rules.filter(elem => elem.operationName == question.operationName)[0].prompt;
            //                     this.addQuestion({
            //                         prompt: usefulPrompt,
            //                         operationName: question.operationName
            //                     }, this.currentQuestion);
            //                 }
            //                 // find a random index between the current spot and the end of the stage
            //                 var randomIndex = Math.round(Math.random() * (this.lessonPlan[this.stages[this.currentStage]].length - this.currentQuestion)) + this.currentQuestion;
            //                 this.addQuestion({
            //                     prompt: "?",
            //                     operationName: question.operationName
            //                 }, randomIndex);
            //                 this.updateProgress();
            //             }
            //             // if in the review stage
            //             // if it's a prompted question, remain on the same question
            //             // if it's an unprompted question, decrement currentQuestion and update progress
            //             // decrementing current question relies on the current structure of the review stage
            //             // which is question with prompt followed by same question without a promt
            //             else if (this.currentStage == 2) {
            //                 if (question.prompt == "?"){
            //                     this.currentQuestion -= 1;
            //                     this.updateProgress();
            //                 }
            //             }
            //             // if it's in the test stage
            //             // change the first prompt in review to indicate that a failure has occurred and the review stage is being started again
            //             // change the index, then update progress (to update the progress of the test stage)
            //             // then change the stage, then update progress again
            //             else if (this.currentStage == 3) {
            //                 this.lessonPlan.Review[0] = {
            //                     prompt: "You got one wrong! Let's review again"
            //                 };
            //                 this.currentQuestion = 0;
            //                 this.updateProgress();
            //                 this.currentStage = 2;
            //                 this.updateProgress();
            //                 this.testFailedNum += 1;
            //                 this.queueNextQuestion();
            //             }
            //         }
            //     }
            // },
        },
        mounted() {
            this.lessonText = {
                Introduction: [
                    {
                        text: "You will be shown which button to press",
                    },
                    {
                        text: "For example, to activate " + this.configObject.rules[0].operationName + ", " + this.configObject.rules[0].hint,
                    },
                    {
                        text: "Try it now",
                    },
                    {
                        text: "? means remember what to press",
                    },
                    {
                        text: "Try it now",
                    },
                    {
                        text: "You got it!",
                    },
                    {
                        text: "There are " + this.configObject.rules.length + " functions to learn",
                    },
                    {
                        text: "Press and release the buttons for each function",
                    },
                ],
                Practice: [
                    {
                        text: "Let's practice the functions",
                    }
                ],
                Review: [
                    {
                        text: "Now we will review all of the functions",
                    }
                ],
                Test: [
                    {
                        text: "Now we will test you. Answering incorrectly will bring you back to the review stage.",
                    }
                ]
            };
            // populate the total
            // skip intro because it has hard coded 2 questions
            var stages = Object.keys(this.stagesToIndex);
            for (let i = 1; i < stages.length; i++){
                for (let j = 0; j < this.configObject.rules.length; j++){
                    if (this.configObject.rules[j].hasOwnProperty(stages[i])){
                        // get the number of questions specified in this rule to add to this stage
                        this.questionTotalCount[stages[i]] += this.configObject.rules[j][stages[i]];
                    }
                    if (i == 1 || i == 2){
                        // in the practice and review stage, the user first goes through
                        // alternating questions before being given the randomised questions
                        // and so each rule adds an additional 2 questions to the total
                        // for this stage
                        this.questionTotalCount[stages[i]] += 2;
                    }
                }
                // we do this because the total count started at 1
                // the total count started at 1 to avoid divide by 0 errors
                // caused by the progress component if the total is 0
                this.questionTotalCount[stages[i]] -= 1;
            }
            window.addEventListener("operated", this.handleOperation);
            this.questionGenerator = new questionGeneratorClass.QuestionGenerator(this.configObject.rules);
            this.startTime = new Date();
            window.setTimeout(this.nextText.bind(this), 3000);
        },
    }
</script>

<style scoped>

.lessonGrid {
    display: grid;
    grid-template-rows: 1fr 3fr 1fr;
    grid-template-columns: 1fr 1fr 1fr;
    width: 100%;
    height: 100%;
    align-items: center;
    justify-items: center;
}

.header {
    grid-column: 2/3;
    grid-row: 1/2;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-items: center;
    text-align: center;
}

.controller {
    grid-column: 1/2;
    grid-row: 2/3;
    grid-template-rows: 4fr 1fr;
}

.function, .hint {
    display: grid;
    grid-template-rows: 1fr 1fr 1fr;
    width: 100%;
    height: 100%;
    align-items: center;
    justify-items: center;
}

.function {
    grid-column: 3/4;
    grid-row: 2/3;
}

.hint {
    grid-column: 2/3;
    grid-row: 2/3;
}

.outcome {
    grid-row: 1/2;
    font-weight: bold;
    font-size: 20px;
}

.middleText {
    grid-row: 2/3;
}

.bottomText {
    grid-row: 3/4;
}

.progress {
    grid-column: 1/4;
    grid-row: 3/4;
    display: flex;
    flex-direction: row;
}


</style>